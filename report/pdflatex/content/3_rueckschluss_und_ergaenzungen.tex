\chapter{Rückschlüsse und Ergänzungen}
\label{chap:Rueckschluesse und Ergaenzunen}

Wie gezeigt in Abbildung \ref{fig:Leistung und Kernenutzung} und \ref{fig:Energiebedarf und Kernenutzung}. Wenn es nur ein Kern aktiviert ist, ist die Energiebedarf des Computersystems am höchsten und dauert die Rechung am längsten. Deshalb die Konfiguration mit nur einem aktivierende Kern ist auf jeden Fall nicht effizient. 

Aber es ist auch komisch, dass die Zeit- und Energiebedarf des Task von 8 Kerne sind beide höher als die von 4 Kerne. Laut der Dokumentation von ODROID-XU3 kann man feststellen, dass es 4 Kerne von Cortex-A7 und 4 Kerne von Cortex-A15 auf der Tafel sich befindet. Wenn es nur 4 Kerne aktiviert ist, sind die 4 Kerne mit niedrigere ID, d.h. 4 Kerne von Cortex-A7 laufbar. 

Der Grunden dafür kann man mit dem Hilfe Dokumentationen und Versuchergebnisse vermuten. Rechnungsdatenumtauschung innerhalb ein CPU ist immer noch effizienter als die über 2 CPUs. Darum ist die Zeitbedarf mit 4 Kerne nideriger. Beschrieben von Webseite von ARM und in Beachtung von Messungsergebnis in Abbildung \ref{fig:Leistung kritischer Teilen}, ist die Leistung des Cortex-A15 höher als die des Cortex-A7 und für die Energiebedarf vice versa. Deshalb für eine Rechnungsarbeit mit so moderatem Maßtab soll man die energieeffiziente CPUs beforzugen.

Die Abbildung \ref{fig:Leistung und Tasks} und ihre Integral \ref{fig:Energiebedarf und Tasks}, Obwohl sich die Konfiguraionen sehr viel verändert, gibt es gar keinen Unterschied bezüglich Leistung dazwischen. Dadurch kann man vermuten, dass währen der Versuchen befindet sich jedes CPU nur auf zwei Zustände: aktiviert oder nicht. Es gibt gar keine Zwischenzustand, auf dem ein CPU mit einer unterschiedlicher Leistung ausgeführt werden kann.

Die Abbildungen \ref{fig:Leistung und Massstab von Tasks} und \ref{fig:Energiebedarf und Massstab von Tasks} zeigen, dass die Maßstäbe der Tasks nichts mit die Leistung des Durchgangs zu tun haben. Nur je größer die Tasks sind, braucht es mehr Zeit die Berechnung zu machen, desto wird mehr Energie insgesamt gebraucht.

Laut der Abbildungen \ref{fig:Leistung und Implementationsmethode} und \ref{fig:Energiebedarf und Implementationsmethode} kann man sagen, dass für diese Versuchtasks spielt OpenMP eine bessere Rolle als MPI, und zusätzlich ist der Durchlauf mit 4 Kerne besser als der mit 8 Kerne. Der Grund dafür kann nicht nur das sein, das im \ref{subsec:Energiebedarf und Architektur} geschieben werden hat, sondern auch wegen der Implementationsmethode. Weil ein lauffähige OpenMP-Programm während der Kompilierenphase in Parallelbereiche zugeordnet worden hat, jedes davon aus viele parallelausführbare Programmteil bestet. In der Durchlaufphase kann es sehr einfach in CPU-kerne zugeordernet. Aber die MPI-Programme brauch Kommunikation durch Peripherien, was eine höhere Zeit- und Energiebedarf verursacht.

Der ganze Versuch stellt her, dass der Energiebedarf unter unsere Untersuchungsplattform zunächst stark abhängig von Anzahl der aktivierte CPUs ist. Einzelne CPU ist auf jeden Fall keine gute Auswahr. Aber wenn man mehrere Kerne gleichzeitig nutzen möchte, erst Linie ist die Kerne innerhalb einem CPU wählen. Weil sie ein L2 Cache besitzen, die die Rechnung und Informationsaustauschen zwischen Kerne wesentlich beschleunigen. Diese verursacht, dass der Durchlauf mit 4 Kerne immer am schnellsten.

Zweitens, die Implementationsmethode spielt auch eine wichtige Rolle. Laut der Dokumentation von OpenMP, die Programme damit wird während der Kompilierung in viele Parallelisierungsbereiche verteilt und jede Bereich hat sind isoliert. Aber für MPI verwendet man ein Kern als Master und es verteilt den Slaves die Teilprogramme. Und diese Verteilung werd mit ein Netzwerkprotocol durchgeführt. Es ist, meiner meinung nach, der Grund dafür, dass MPI in unseren Versuchen langsamer als OpenMP ist. 

Zur Ergänzungen, dass es für beide MPI und OpenMP, beziehungsweise für die CPUs sich selbe noch viele regelbare Parameteren gibt, zum Beispiel Environment Variable OPM\_NUM\_THREADS bestimmt die Anzahl von Threads zu aktivieren für einen Parallelbereich, und ebenfalls für mpi Ausführungsprogramm mpirun.mpich gibt es auch viele sachen die regelbar sind. Mit einer optimierten Konfiguration kann man vieleicht noch mehr Energie sparren.
